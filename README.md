# PR Reviewer Assignment Service (Тестовое задание Авито, осень 2025)

Микросервис для автоматического назначения ревьюверов на Pull Request’ы, управления командами и активностью пользователей. Взаимодействие происходит исключительно через HTTP API (см. `openapi.yml`).

## Технологический стек

- Язык: Go
- База данных: PostgreSQL (по ТЗ рекомендована; фактический выбор описать здесь)
- Запуск: через `docker-compose up` (сервис на порту `8080`)

## Структура домена (по ТЗ)

- **User** — участник команды:
  - `user_id` — уникальный идентификатор
  - `username`
  - `is_active` — флаг активности
- **Team** — группа пользователей:
  - `team_name` — уникальное имя
  - список участников
- **Pull Request (PR)**:
  - `pull_request_id`
  - `pull_request_name`
  - `author_id`
  - `status`: `OPEN | MERGED`
  - `assigned_reviewers` — до 2 ревьюверов

## Чеклист реализации / текущий статус

### 1. Доменные модели и слои

- [x] Определить доменные модели `User` и `Team` (структуры в пакете `model`).
- [x] Определить доменную модель `PullRequest` с полями по `openapi.yml`.
- [x] Ввести пакеты `errs` для разных слоёв (репозиторий/сервис) с явными перечислениями ошибок.
- [ ] Ввести единый тип доменной ошибки (например, `AppError` с `code` из `ErrorResponse` в `openapi.yml`).
- [x] Реализовать базовый сервисный слой для команд:
  - интерфейс `TeamService`
  - методы `CreateTeam` и `GetTeam`.
- [x] Реализовать сервисный слой для пользователей (`UserService`).
- [x] Реализовать сервисный слой для PR (`PullRequestService`):
  - создание PR;
  - merge (идемпотентный);
  - переназначение ревьювера;
  - выборка PR по ревьюверу.

### 2. Слой хранения данных (репозитории)

- [x] Описать интерфейсы `TeamRepository` и `UserRepository`.
- [x] Описать интерфейс `PullRequestRepository`.
- [x] Реализовать репозиторий команд (PostgreSQL / выбранная БД):
  - создание команды;
  - проверка существования по имени;
  - получение команды с участниками.
- [x] Реализовать репозиторий пользователей:
  - создание/обновление пользователя (upsert);
  - получение по `user_id`;
  - обновление флага `is_active`.
- [x] Реализовать репозиторий PR:
  - создание PR;
  - сохранение статуса `OPEN/MERGED`;
  - привязка ревьюверов;
  - выборка PR по ревьюверу.
- [x] Добавить типовые ошибки репозитория (`ErrNotFound`, `ErrDuplicate`, `ErrConstraint`) и использовать их в сервисном слое для маппинга в доменные ошибки.

### 3. Бизнес-логика назначения ревьюверов

- [x] При создании PR (**/pullRequest/create**):
  - находить автора;
  - определять его команду;
  - выбирать **до двух** активных ревьюверов из команды автора, **исключая автора**;
  - если доступных кандидатов меньше двух — назначать 0/1 ревьювера;
  - не назначать пользователей с `is_active = false`.
- [x] При переназначении ревьювера (**/pullRequest/reassign**):
  - убедиться, что PR существует и не в статусе `MERGED`;
  - убедиться, что `old_user_id` действительно назначен ревьювером этого PR;
  - выбрать случайного активного участника из команды **старого ревьювера**;
  - заменить старого ревьювера на нового;
  - если в команде нет активных кандидатов — вернуть доменную ошибку `NO_CANDIDATE`.
- [x] После статуса `MERGED`:
  - запретить изменение списка ревьюверов;
  - при попытке переназначения возвращать `PR_MERGED` (HTTP 409).
- [x] Учесть, что пользователь с `is_active = false` никогда не должен назначаться ревьювером (ни при создании PR, ни при переназначении).

### 4. HTTP API (по `openapi.yml`)

#### 4.1 Команды

- [ ] **POST /team/add**
  - Создать новую команду с участниками.
  - Если команда уже существует — вернуть `400` + `error.code = TEAM_EXISTS`.
  - При создании команды:
    - создать/обновить пользователей с привязкой к команде;
    - обеспечить уникальность имени команды.
- [ ] **GET /team/get**
  - Получить команду с участниками по `team_name`.
  - При отсутствии команды — вернуть `404` + `ErrorResponse` (`NOT_FOUND`).

#### 4.2 Пользователи

- [ ] **POST /users/setIsActive**
  - Установить флаг активности пользователя.
  - Обновить `is_active` в БД.
  - При отсутствии пользователя — вернуть `404`.

- [ ] **GET /users/getReview**
  - Вернуть список PR, где пользователь назначен ревьювером:
    - `pull_request_id`
    - `pull_request_name`
    - `author_id`
    - `status`.
  - Обработать случай отсутствия PR (возвращать пустой список).

#### 4.3 Pull Request’ы

- [ ] **POST /pullRequest/create**
  - Завязать сервис на HTTP: принимать входной DTO, вызывать `PRService.CreatePR`, маппить доменные ошибки (`ErrUserNotFound`, `ErrPRExists`, `ErrNoCandidates`) в HTTP-коды/ответы.
- [ ] **POST /pullRequest/merge**
  - Подключить сервисный метод `Merge`, вернуть итоговую DTO.
- [ ] **POST /pullRequest/reassign**
  - Вызывать `Reassign`, маппить `ErrPRMerged`, `ErrReviewerMissing`, `ErrNoCandidates` в `409` + `ErrorResponse`.

### 5. Обработка ошибок

- [x] Ввести отдельные наборы ошибок для сервисного и репозиторного слоёв (пакеты `errs`).
- [ ] Добавить доменный тип ошибки с полем `code`, совпадающим с enum из `ErrorResponse` (`TEAM_EXISTS`, `PR_EXISTS`, `PR_MERGED`, `NOT_ASSIGNED`, `NO_CANDIDATE`).
- [ ] В сервисном слое маппить:
  - технические ошибки репозитория (`ErrNotFound`, `ErrDuplicate`) → доменные;
  - доменные ошибки → коды из `ErrorResponse`.
- [ ] В HTTP-слое (хэндлеры):
  - по доменному `code` выбирать HTTP-статус (400/404/409);
  - возвращать JSON в формате `ErrorResponse` из `openapi.yml`.

### 6. Нефункциональные требования

- [ ] Обеспечить работу сервиса при нагрузке до 5 RPS.
- [ ] Держать время ответа в пределах 300 мс (SLI).
- [ ] Обеспечить успешность 99.9% для корректных запросов (за счёт устойчивости к ошибкам и аккуратной обработке).
- [ ] Реализовать простое логирование запросов и ошибок.
- [ ] Добавить базовое мониторинг/health-check:
  - [ ] **GET /health** (можно добавить отдельный эндпоинт или использовать существующий паттерн).

### 7. Инфраструктура и деплой

- [ ] Описать Dockerfile для сервиса.
- [ ] Описать `docker-compose.yml`, поднимающий:
  - сервис;
  - базу данных;
  - (опционально) контейнер с миграциями.
- [ ] Обеспечить запуск всего проекта командой:
  - `docker-compose up`
- [ ] Гарантировать, что при `docker-compose up`:
  - применяются миграции;
  - сервис доступен на порту `8080`.

### 8. Дополнительные задания (опционально)

- [ ] Эндпоинт статистики:
  - простая статистика по:
    - количеству назначений ревьюверов по пользователям;
    - количеству PR по статусам.
- [ ] Нагрузочное тестирование:
  - [ ] подготовить сценарий (например, k6/JMeter);
  - [ ] приложить краткие результаты (tps, latency, error rate).
- [ ] Массовая деактивация пользователей команды:
  - [ ] реализовать метод массовой деактивации;
  - [ ] безопасно переназначать ревьюверов в открытых PR;
  - [ ] стремиться уложиться в 100 мс для средних объёмов данных.
- [ ] Интеграционные / E2E тесты:
  - [ ] прогон основных сценариев через HTTP;
  - [ ] поднятие тестовой БД (in-memory/pgsql) для прогонов.
- [ ] Конфигурация линтера:
  - [ ] добавить конфиг (например, для `golangci-lint`);
  - [ ] описать команду запуска в `Makefile`.

### 9. Makefile и запуск

- [ ] Добавить `Makefile` с основными командами:
  - `make build` — сборка сервиса;
  - `make test` — запуск тестов;
  - `make lint` — запуск линтера;
  - `make run` — локальный запуск (без docker-compose).
- [ ] Описать в этом README:
  - требования (Go-версия, Docker, docker-compose);
  - шаги по запуску сервиса локально и через Docker.

## Вопросы и допущения

В этом разделе нужно фиксировать решения, принятые при отсутствии явных указаний в ТЗ.

Примеры того, что стоит сюда записывать:

- Формат и стратегия генерации `pull_request_id`, если он не задаётся извне.
- Поведение при повторном вызове `/team/add` с другой конфигурацией участников (жёсткий запрет или попытка синхронизации состава?).
- Выбранная база данных и причины выбора (если не PostgreSQL).
- Выбор конкретной стратегии рандомизации при назначении ревьюверов.
- Любые отклонения от `openapi.yml` (если они есть и почему без этого нельзя).
